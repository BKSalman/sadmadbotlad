diff --git a/src/irc.rs b/src/irc.rs
index e286784..63be998 100644
--- a/src/irc.rs
+++ b/src/irc.rs
@@ -89,6 +89,7 @@ async fn read(
                         .expect("queue lock")
                         .enqueue(song)
                         .expect("Enqueuing");
+
                 } else if parsed_msg.starts_with("!skip") {
                     if let Err(e) = mpv.playlist_next_force() {
                         println!("{e}");
@@ -138,11 +139,11 @@ async fn read(
 }
 
 fn parse_message(msg: &str) -> String {
-    msg.trim()[(&msg[1..]).find(':').unwrap() + 2..]
+    msg.trim().to_ascii_lowercase()[(&msg[1..]).find(':').unwrap() + 2..]
         .replace("\r\n", "")
         .to_string()
 }
 
 fn parse_sender(msg: &str) -> String {
-    msg.trim()[1..msg.find('!').unwrap()].to_string()
+    msg.trim().to_ascii_lowercase()[1..msg.find('!').unwrap()].to_string()
 }
diff --git a/src/song_requests.rs b/src/song_requests.rs
index 1dcac4c..ca15708 100644
--- a/src/song_requests.rs
+++ b/src/song_requests.rs
@@ -49,20 +49,19 @@ impl Queue {
     }
 
     pub fn dequeue(&mut self) -> Result<(), &'static str> {
-
         self.current_song = self.queue[0].clone();
 
         for i in 0..self.rear - 1 {
             self.queue[i] = self.queue[i + 1].clone();
             self.queue[i + 1] = None;
         }
-        
+
         if self.rear == 1 {
             self.queue[0] = None;
         }
-        
+
         self.rear -= 1;
-        
+
         Ok(())
     }
 }
@@ -86,20 +85,20 @@ pub fn play_song(mut receiver: Receiver<SongRequest>, mpv: Arc<Mpv>, queue: Arc<
         .disable_deprecated_events()
         .expect("deprecated events");
 
-        if let Some(song) = receiver.blocking_recv() {
-            mpv.playlist_load_files(&[(&song.song, FileState::AppendPlay, None)])
-                .expect("play song");
-
-            if let Err(e) = queue.lock().expect("queue lock").dequeue() {
-                println!("play_song:: {e}");
-            }
+    if let Some(song) = receiver.blocking_recv() {
+        mpv.playlist_load_files(&[(&song.song, FileState::AppendPlay, None)])
+            .expect("play song");
 
-            println!("{song:?}");
+        if let Err(e) = queue.lock().expect("queue lock").dequeue() {
+            println!("play_song:: {e}");
         }
 
+        println!("{song:?}");
+    }
+
     loop {
         let ev = event_ctx
-            .wait_event(120.)
+            .wait_event(600.)
             .unwrap_or(Err(libmpv::Error::Null));
 
         match ev {
@@ -109,11 +108,11 @@ pub fn play_song(mut receiver: Receiver<SongRequest>, mpv: Arc<Mpv>, queue: Arc<
                         .expect("play song");
 
                     let mut locked_queue = queue.lock().expect("queue lock");
-                    
+
                     if locked_queue.rear == 0 {
                         locked_queue.current_song = None;
                     }
-                    
+
                     if let Err(e) = locked_queue.dequeue() {
                         println!("play_song:: {e}");
                     }
@@ -122,7 +121,22 @@ pub fn play_song(mut receiver: Receiver<SongRequest>, mpv: Arc<Mpv>, queue: Arc<
                 }
             }
             Ok(_) => {}
-            Err(e) => println!("{e}"),
+            Err(e) => {
+                queue.lock().expect("queue lock").current_song = None;
+
+                println!("MpvEvent:: {e}");
+
+                if let Some(song) = receiver.blocking_recv() {
+                    mpv.playlist_load_files(&[(&song.song, FileState::AppendPlay, None)])
+                        .expect("play song");
+
+                    if let Err(e) = queue.lock().expect("queue lock").dequeue() {
+                        println!("play_song:: {e}");
+                    }
+
+                    println!("{song:?}");
+                }
+            }
         }
     }
 }
